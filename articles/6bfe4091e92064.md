---
title: 自作OS on Raspberry Pi 5 - Part 3. RP1 MSI-X
emoji: 🍓
type: tech
topics:
  - Zig
  - 自作OS
  - Raspberry Pi 5
  - aarch64
  - MSI-X
published: true
---

「気が向いたので自作 OS on Raspberry Pi 5 in Zig を書いてみよう」シリーズのパート3です。

https://github.com/smallkirby/urthr/tree/4a210d38c6b3e3b6be5a00216567bd0244eb4c34

---

## 概要

前回作った Ethernet MAC (GEM) ドライバでは、パケットを受信したときにそれを知る方法が RxQueue 内の descriptor の値をポーリングするしかありませんでした。CPU もずっと同じところを見続けていると気持ちが落ち込んでしまうと思うので、割り込みによって受信を通知できるようにしたいところです。Raspberry Pi 5 では、多くのペリフェラルが **RP1** という I/O コントローラ経由で SoC に接続されています。SoC と RP1 は PCIe で接続されています。よって、ペリフェラルが発する割り込みもこの PCIe 経由で SoC に通知されることになります。具体的には、**MSI-X** の仕組みを使って割り込みが発行されます。今回は Ethernet MAC が MSI-X を使って受信を通知できるようにすることを目標にします。

## 大まかな流れ

Ethernet MAC がパケットを受信してから CPU に割り込みが届くまでには、大まかに以下の流れをたどります:

1. Ethernet MAC がパケットを受信し、RxQueue 内の空いている (=  HW 所有) ディスクリプタに情報を書き込んで SW 所有にする
2. PCIe EP (RP1側) が自身の **MSI-X Table** を参照し、Ethernet MAC の Vector ID に対応する Table Entry から通知先の PCIe アドレスを探す
3. EP が PCIe Memory Write TLP を 3 で発見した PCIe アドレスに対して発行する
4. SoC 側の **MIP (MSI-X Interrupt Peripheral)** に Write が届き、data の値に応じた SPI を GIC に発行する

## MSI-X Capability

まずは前提条件として MSI-X がサポートされているかどうかをチェックします。まぁサポートされていることは分かっているんですけど。MSI-X の情報は PCI の **Capability List** を辿ることで探します。Capability List は PCI Configuration Space の固定アドレスから始まり、全 capability が以下の共通ヘッダを持ちます:

```zig
/// Generic capability header.
pub const CapHeader = packed struct(u32) {
    /// Capability ID.
    id: CapId,
    /// Next Capability Pointer.
    next: u8,
    /// Capability-specific data.
    _rsvd: u16,
};
```

`next` フィールドが次の capability header の、Configuration Space 先頭からのオフセットです。`id` は capability に応じた ID であり、MSI-X の場合は `0x11` です。ヘッダに続くデータは capability によって異なり、MSI-X の場合には以下の 4 x 3 bytes の情報を持ちます。

```zig
/// MSI-X Capability Structure.
const MsixCap = packed struct(u32) {
    /// Capability ID.
    id: CapId = .msix,
    /// Next Capability Pointer.
    next: u8,

    /// Table Size - 1.
    table_size: u11,
    /// Reserved.
    _rsvd: u3 = 0,
    /// Global Function Mask.
    function_mask: bool,
    /// MSI-X Enable.
    enabled: bool,
};

/// MSI-X Table Offset/BIR.
const MsixTableOffset = packed struct(u32) {
    /// BAR Indicator Register.
    bir: u3,
    /// Offset within the BAR (8-byte aligned).
    offset: u29,
};

/// MSI-X PBA BIR and Offset.
const MsixPbaOffset = packed struct(u32) {
    /// BAR Indicator Register.
    bir: u3,
    /// Offset within the BAR.
    offset: u29,
};
```

**PBA (Pending Bit Array)** は今回は扱わないので無視。大事なのは MSI-X Table のサイズと BAR とオフセットです。MSI-X Table は EP 側が持っており、BAR によってマップします。**BIR (BAR Indicator Register)** は Table がどの BAR によって張られるかを示しており、offset フィールドは BAR によって張られる空間の先頭から Table までのオフセットを示します。size はテーブルのエントリ数です。
手元の Raspberry Pi 5 だと、MSI-X Capability は以下のようになっていました:

```txt
MsixCap         : 0x003C0011
MsixTableOffset : 0x00000000
MsixPbaOffset   : 0x00002000
```

パースすると以下になります:

- Table BAR: BAR0
- Table Offset: `0`
- Table Size: `61` (`0x3C + 1`)

## MSI-X Table

Capability List から取得した情報をもとに、**MSI-X Table** を設定していきます。MSI-X Table の各エントリは、以下の 128 bit 構造体で表現されます:

```zig
const MsixEntry = packed struct (u128) {
    /// Message Address
    address: u64,
    /// Message Data
    data: u32,
    /// Vector Control
    control: u32
};
```

**Vector Control** は、0-bit 目がマスクの有効化を指定します (マスクされていると割り込みが入ってこない)。**Data** の解釈はおそらく割り込みコントローラに依存するような気がしますが、Raspberry Pi 5 の場合には、ここに書いた値に応じた割り込みが発行されます。より具体的には、**data に書いた値 + 128 の SPI** が発行されます。SPI ベースなので、割り込み番号自体は `data + 128 + 32` 番が発行されることになります。これらの値については [rpi-linux の Devicetree](https://github.com/raspberrypi/linux/blob/0ad641150c52aaaaba11365dab3efa29a68eb0ba/arch/arm64/boot/dts/broadcom/bcm2712.dtsi#L567-L574) を参考にしました:

```dts
mip0: msi-controller@1000130000 {
    compatible = "brcm,bcm2712-mip";
    reg = <0x10 0x00130000 0x00 0xc0>,
          <0xff 0xfffff000 0x00 0x1000>;
    msi-controller;
    msi-ranges = <&gicv2 GIC_SPI 128 IRQ_TYPE_EDGE_RISING 64>;
    brcm,msi-offset = <0>;
};
mip1: msi-controller@1000131000 {
    compatible = "brcm,bcm2712-mip";
    reg = <0x10 0x00131000 0x00 0xc0>,
          <0xff 0xfffff000 0x00 0x1000>;
    msi-controller;
    msi-ranges = <&gicv2 GIC_SPI 247 IRQ_TYPE_EDGE_RISING 8>;
    brcm,msi-offset = <8>;
};
```

なお RPi5 には MIP が2つ載っているようですが、RP1 に接続されている `pcie2` が使っているのは MIP0 の方です。MIP1 は SPI 247 からを使うようですね。

さてさて、MSI-X Table はこの 128-bit エントリの配列になっているわけですが、何番目のエントリがどのペリフェラルに対応するかは HW 的に決まっています。RP1 のデータシートを見ても載っていないので、知る術は Linux の Devicetree を参照するのみです。Ethernet MAC の場合には[以下のようになっています](https://github.com/raspberrypi/linux/blob/0ad641150c52aaaaba11365dab3efa29a68eb0ba/arch/arm64/boot/dts/broadcom/rp1.dtsi#L999-L1016):

```dts
rp1_eth: ethernet@100000 {
    reg = <0xc0 0x40100000  0x0 0x4000>;
    compatible = "raspberrypi,rp1-gem", "cdns,macb";
    #address-cells = <1>;
    #size-cells = <0>;
    interrupts = <RP1_INT_ETH IRQ_TYPE_LEVEL_HIGH>;
    ...
};
```

[`rp1.h`](https://github.com/raspberrypi/linux/blob/0ad641150c52aaaaba11365dab3efa29a68eb0ba/include/dt-bindings/mfd/rp1.h#L112) を眺めると、以下のように定義されています:

```h
#define RP1_INT_IO_BANK0 0
#define RP1_INT_IO_BANK1 1
#define RP1_INT_IO_BANK2 2
#define RP1_INT_AUDIO_IN 3
#define RP1_INT_AUDIO_OUT 4
#define RP1_INT_PWM0 5
#define RP1_INT_ETH 6
#define RP1_INT_I2C0 7
```

というわけで、Ethernet MAC には MSI-X Vector 6 番が割り当てられていることが推測できます。よって、MSI-X Table の6番目のエントリを設定してあげればよいということになります。

先程の Capability の情報から、RPi5 では BAR0 (+ offset 0) に MSI-X Table がマップしてあることがわかります。というわけで、適当な AXI 空間を BAR0 にマップしてあげることで EP 側の MSI-X テーブルにアクセスすることができるようになります。 というわけで、RP1 との Configuration Space に設定する BAR は今までと合わせて以下のようになります。どれも 32bit Memory I/O でした:

- BAR0: MSI-X Table
- BAR1: RP1 のペリフェラルたち
- BAR2: Shared SRAM (Mailbox 経由のやりとりに使ったりする)

6番目のエントリは以下のように設定します:

- Address: MIP0 の PCI アドレス
- Data: 任意 (発生させたい SPI 番号に応じて)
- Vector Control: `0` (マスクを外す)

## Inbound Address Translation

先程 MSI-X Table の Message Address として MIP0 の PCI アドレスを指定しました。ということは、PCIe RC 側に適切に Inbound Address Translation (PCI → AXI 変換) を設定してあげる必要があります。MIP0 の AXI MMIO アドレスは `0x10_0013_0000` で固定です。対して、PCI アドレスとして何を使うかはおそらく自由なのではないかという気がしています。しかし、前回のブログでもあったように利用可能な PCI アドレス範囲自体は HW 的に決まっているため、ここは同じ過ちを繰り返さないよう Devicetree で指定されているアドレス `0xFF_FFFF_F000` をそのまま使うことにします。EP 側の BAR も Linux に倣って BAR1 を使いましょう:

```zig
const mip0_range = DmaRange{
    .pci = 0xFF_FFFF_F000,
    .axi = 0x10_0013_0000,
    .size = 0x0000_1000,
};
pcie.setInTranslation(
    mip0_range.pci,
    mip0_range.axi,
    mip0_range.size,
    1,
);
```

これで、Ethernet MAC が割り込みを発生するときには以下の流れになります:

- MSI-X Table の 6 番目のエントリを参照
- EP が Message Address である `0xFF_FFFF_F000` に PCI Write 発行
- RC の Inbound Translation で AXI `0x10_0013_0000` (MIP0 MMIO 領域) に変換されて、Write
- MIP0 が Message Data + 128 + 32 の割り込みを発行

## RP1 固有の設定

RP1 には PCIe Endpoint Controller モジュールの中に、追加の MSI-X 用の設定レジスタがあります。PCIe Endpoint Controller は、BAR1 でマップされる空間からオフセット`0x0010_8000` の位置に存在します。MSI-X 用のレジスタ群 **`MSIX_CFG_<n>`** はここからオフセット `0x08` の位置に 64 個存在します (各32bit)。各レジスタは先程触れた MSI-X Vector に対応するペリフェラル用の設定を担当し、Ethernet の場合は 6 番目です。[RP1 Datasheet](https://pip.raspberrypi.com/documents/RP-008370-DS-1-rp1-peripherals.pdf) によると、各レジスタは以下の構造を持ちます:

![](/images/rp1-msixcfg.png)

**IACK_EN** は MSI-X 割り込みを送信する際に、割り込みソースをマスクする機能です。有効化した場合は、MSI-X 割り込み後に **IACK** ビットに書き込むまではそのペリフェラルから MSI-X 割り込みが発行されることがなくなります。IACK に書き込む時にすでに割り込みが pending している状態であれば、すぐさま MSI-X 割り込みが発生します。まぁ使っても使わなくても良いのではないでしょうか。重要なのは **ENABLE** ビットで、これをセットしないと MSI-X 割り込みが発行されないため、忘れずセットしておきます。

## MIP の設定

MIP の設定も必要な場合があるっぽいです。Linux だと [`irq-bcm2712-mip.c`](https://github.com/raspberrypi/linux/blob/0ad641150c52aaaaba11365dab3efa29a68eb0ba/drivers/irqchip/irq-bcm2712-mip.c) に相当します。`INT_MASKL_HOST` と `INT_MASKH_HOST` が割り込みマスクに相当するらしいのでこれをクリアします。ただ、 手元の Raspberry Pi 5 だとリセット値がオールゼロだったため、特に明示的にクリアする必要はありませんでした。

## アウトロ

さてさて、これで MSI-X で割り込みを受け取る準備が整いました。そういえば Urthr には割り込みコントローラのドライバが無かったため、[GICv2 と GICv3 の簡単なドライバを生やしました](https://github.com/smallkirby/urthr/blob/4a210d38c6b3e3b6be5a00216567bd0244eb4c34/urthr/arch/aarch64/gicv2.zig)。RPi4b と RPi5 は GICv2 で、QEMU virt マシンが GICv3 です。これを使って、適当に割り込みハンドラを登録できるようにしました。MSI-X Table の 6 番目に、Data として `6` を指定しました。よって、SPI 128 + 6 、つまり割り込みの 128 + 6 + 32 = 166 番目が GEM の受信通知として送信されるはずです。この状態で、別の Linux マシンから1秒ごとに ARP リクエストを送信してみます。結果やいかに:

![](/images/msi-x.gif)

だいたい1秒おきくらいにパケットが受信できていそうです。受信したパケットの内容も ARP でした。やった〜〜〜。

## References

### MSI-X

- https://mmi.hatenablog.com/entry/2017/03/28/032646
- https://zenn.dev/junjunjunjun/articles/a6bc6f33789458

### Raspberry Pi 5 MSI

- https://lwn.net/Articles/979758/
- https://github.com/raspberrypi/linux/blob/0ad641150c52aaaaba11365dab3efa29a68eb0ba/drivers/irqchip/irq-bcm2712-mip.c
